import asyncio
import itertools
import time
from collections import defaultdict
from typing import Dict, List

import aiohttp

import click
from src import consts, utils


class Percentage:
    """a descriptor class for storing a percentage 0-100"""

    def __set__(self, instance, value):
        if value < 0 or value > 100:
            raise ValueError(f"expecting a value between 0-100 in {self.name}")
        instance.__dict__[self.name] = value

    def __set_name__(self, owner, name):
        self.name = name


class Issue:
    """class representing a github issue"""

    risk = Percentage()  # descriptor for keeping it 0-100

    def __init__(self, title: str, body: str, risk: float):
        self.title = title
        self.body = body
        self.risk = risk

    def __repr__(self):
        return f"<Issue title={self.title} risk={self.risk}>"


def calculate_risk(issue: dict, risk_factor: int) -> float:
    """calculate the risk of an issue:
    multiply the risk factor with the relevance of this issue"""
    score = 1
    if issue["score"] < 1:  # score can be 1800. we are not fine with that
        # let's just lower our risk if the issue is not relevant
        score = issue["score"]
    return risk_factor * score  # adjust the factor with the relevance of the topic


async def get_risk_by_keyword(
    session: aiohttp.ClientSession,
    keyword: str,
    repo_name: str,
    risk_factor: int,
    issues: Dict[int, list],
) -> float:
    """loop over a single request from GitHub API"""
    final_risk: float = 0
    url = (
        f"https://api.github.com/search/issues?q={keyword}+repo:{repo_name}+type:issue"
    )
    response = await session.get(url)
    result = await response.json()
    try:
        for issue in result["items"]:
            risk = calculate_risk(issue, risk_factor)
            final_risk += risk
            issues[risk_factor].append(
                Issue(title=issue["title"], body=issue["body"], risk=risk)
            )
    except KeyError:  # no items key
        pass

    click.secho(f"[+] Risk of {keyword}: {final_risk}%")
    return final_risk


async def scan(issues: Dict[int, list], repo_name: str):
    """Main method for scanning all of our keywords with GitHub API
    and determine risks"""
    final_risk: float = 0
    async with aiohttp.ClientSession() as session:
        for risk_factor, keywords in consts.RISK_KEYWORDS.items():
            tasks = [
                get_risk_by_keyword(
                    session=session,
                    keyword=keyword,
                    repo_name=repo_name,
                    risk_factor=risk_factor,
                    issues=issues,
                )
                for keyword in keywords
            ]
            results = await asyncio.gather(*tasks)
            final_risk += sum(results)
    final_risk = round(final_risk, 2)  # round to 2 decimal points
    click.secho(
        f"[+] Chances of a vulnerability: {max(final_risk, 0)}%", fg="red", bold=True
    )


@click.command()
@click.option("-v", "--verbose", count=True)
@click.option(
    "--repo_url",
    prompt="Repository URL",
    help="The repository to scan.",
    required=True,
)
def main(repo_url: str, verbose: bool = False):
    repo_name = utils.get_repo_name_from_url(repo_url)
    issues: Dict[int, list] = defaultdict(list)
    click.secho("[+] Starting to analyze...", fg="green", bold=True)
    asyncio.run(scan(issues, repo_name))
    if verbose:
        click.secho("Issues scanned:", bold=True, fg="cyan")
        for issues_list in issues.values():
            for issue in issues_list:
                click.secho(f"{issue.title} - {issue.risk}%")


if __name__ == "__main__":
    main()
